/* e2_trace
 *
 *   
*/
#ifndef E2_TRACE_INCLUDED
#define E2_TRACE_INCLUDED

#include "p7_config.h"

#include <stdio.h>		/* FILE */

#ifdef HAVE_MPI
#include "mpi.h"
#endif

#include "easel.h"
#include "esl_alphabet.h"	/* ESL_DSQ, ESL_ALPHABET */
#include "esl_dmatrix.h"	/* ESL_DMATRIX           */
#include "esl_getopts.h"	/* ESL_GETOPTS           */
#include "esl_tree.h"

#include "e2_profile.h"
#include "e2_profilesq.h"
#include "e2hmmer_profile.h"

/*****************************************************************
 * 5. E2_TRACE:  a traceback (alignment of a descendant to an ancestral profile).
 *****************************************************************/
/* Traceback structure for alignment of a sequence to a model.
 *
 * A traceback only makes sense in a triplet (tr, gm, dsq), for a
 * given model profile (gm), and  given digital sequence
 * (with positions 1..L).
 * 
 * A profile's B,S,D states emit the ancestral sequence on transition, not on state.
 * So a path of B emits 0 ancestral residues, BS emits 1 ancestral residue, BSS emits 2
 * ancestralresidues, and so on. By convention, the trace always associates an
 * emission-on-transition with the trailing (destination) state, so
 * the first N, C, or J is stored in a trace as a nonemitter (i=0).
 *
 * A k coords in a traceback are usually 1..M with respect to an
 * ancestral sequence.
 *
 * A i coords in a traceback are usually 1..L with respect to an
 * unaligned digital target sequence, but in the special case of
 * traces faked from existing MSAs, the coords may
 * be 1..alen relative to an MSA's columns.
 */


typedef struct e2_trace_s {
  int    N;		/* length of traceback                            */
  int    nalloc;        /* allocated length of traceback                  */
  int   *st;		/* state type code                      [0..N-1]  */
  int   *k;		/* pos in model, 1...M; else 0 [0..N-1]           */
  int   *a;		/* ancestral pos emitted, 1...M; else 0 [0..N-1]  */
  int   *i;		/* pos emitted in psql, 1..Ll; else 0    [0..N-1] */
  int   *j;		/* pos emitted in psqr, 1..Lr; else 0    [0..N-1] */
  float *pp;		/* posterior prob of x_i; else 0        [0..N-1]  */
  int    M;		/* ancestral length                               */
  int    Lrow;		/* length of sqrow (maximum i)                    */
  int    Lcol;		/* length of sqcol (maximum j)                    */

  enum e2p_sq_e  rowsq;  /* connects the tree order (sql,sqr) with the dp order (sqrow,sqcol) */

  /* The following section is data generated by "indexing" a trace's domains */
  int   ndom;		/* number of domains in trace (= # of I states + 1)  */
  int  *tfrom,   *tto;	/* locations of B/E states in trace (0..tr->N-1)     */
  int  *sqfrom,  *sqto;	/* last/first I-emitted residue on sequence (1..L)   */
  int  *anfrom,  *anto; /* last/first I state on ancestral sequence (1..M)   */
  int   ndomalloc;	/* current allocated size of these stacks            */

} E2_TRACE;

enum apair_e{
  PAIR = 0,
  LRES = 1,
  RRES = 2,
  NONE = 3,
};

/* e2_trace.c */
extern E2_TRACE *e2_trace_Create(void);
extern E2_TRACE *e2_trace_CreateWithPP(void);
extern int       e2_trace_Reuse(E2_TRACE *tr);
extern int       e2_trace_Grow(E2_TRACE *tr);
extern int       e2_trace_GrowIndex(E2_TRACE *tr);
extern int       e2_trace_GrowTo(E2_TRACE *tr, int N);
extern int       e2_trace_GrowIndexTo(E2_TRACE *tr, int ndom);
extern void      e2_trace_Destroy(E2_TRACE *tr);
extern void      e2_trace_DestroyArray(E2_TRACE **tr, int N);

extern int       e2_trace_Dump(FILE *fp, const E2_TRACE *tr, const E2_PROFILE *gm, const E2HMMER_PROFILE *gm7, const PSQ *sq1, const PSQ *sq2, const PSQ *sqa);

extern int       e2_trace_Append      (E2_TRACE *tr, int st, int k, int a, int i, int j);
extern int       e2_trace_AppendWithPP(E2_TRACE *tr, int st, int k, int a, int i, int j, float pp);
extern int       e2_trace_Reverse     (E2_TRACE *tr);
extern int       e2_trace_Index       (E2_TRACE *tr);
#endif
