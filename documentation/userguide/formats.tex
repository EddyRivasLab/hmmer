\chapter{File formats}

\section{HMMER save files}

The file \prog{Demos/rrm.hmm} gives an example of a HMMER ASCII save
file. An abridged version is shown here, where (\ldots) mark deletions
made for clarity and space:

{\small\begin{verbatim}
HMMER2.0
NAME  rrm
ACC   PF00076
DESC  RNA recognition motif. (aka RRM, RBD, or RNP domain)
LENG  72
ALPH  Amino
RF    no
CS    no
MAP   yes
COM   ../src/hmmbuild -F rrm.hmm rrm.slx
COM   ../src/hmmcalibrate rrm.hmm
NSEQ  70
DATE  Wed Jul  8 08:13:25 1998
CKSUM 2768
GA    13.3 0.0
TC    13.40 0.60
NC    13.20 13.20
XT      -8455     -4  -1000  -1000  -8455     -4  -8455     -4 
NULT      -4  -8455
NULE     595  -1558     85    338   -294    453  -1158    (...)
EVD   -49.999123   0.271164
HMM        A      C      D      E      F      G      H      I (...)
         m->m   m->i   m->d   i->m   i->i   d->m   d->d   b->m   m->e
          -21      *  -6129
     1  -1234   -371  -8214  -7849  -5304  -8003  -7706   2384  (...) 1
     -   -149   -500    233     43   -381    399    106   -626  (...)
     -    -11 -11284 -12326   -894  -1115   -701  -1378    -21      * 
     2  -3634  -3460  -5973  -5340   3521  -2129  -4036   -831  (...) 2
     -   -149   -500    233     43   -381    399    106   -626  (...)
     -    -11 -11284 -12326   -894  -1115   -701  -1378      *      * 
(...)
    71  -1165  -4790   -240   -275  -5105  -4306   1035  -2009  (...) 90
     -   -149   -500    233     43   -381    398    106   -626  (...)
     -    -43  -6001 -12336   -150  -3342   -701  -1378      *      * 
    72  -1929   1218  -1535  -1647  -3990  -4677  -3410   1725  (...) 92
     -      *      *      *      *      *      *      *      *  (...) 
     -      *      *      *      *      *      *      *      *      0 
//
\end{verbatim}}

HMMER2 profile HMM save files have a very different format compared to
the previous HMMER1 ASCII formats. The HMMER2 format provides all the
necessary parameters to compare a protein sequence to a HMM, including
the search mode of the HMM (hmmls, hmmfs, hmmsw, and hmms in the old
HMMER1 package), the null (background) model, and the statistics to
evaluate the match on the basis of a previously fitted extreme value
distribution.

The format consists of one or more HMMs. Each HMM starts with the
identifier ``HMMER2.0'' on a line by itself and ends with // on a line
by itself. The identifier allows backward compatibility as the HMMer
software evolves. The closing // allows multiple HMMs to be
concatenated into a single file to provide a database of HMMs.

The format for an HMM is divided into two regions. The first region
contains text information and miscalleneous parameters in a (roughly)
tag-value scheme, akin to EMBL formats. This section is ended by a
line beginning with the keyword \prog{HMM}. The second region is of a
more fixed format and contains the main model parameters. It is ended
by the // that ends the entire definition for a single profile-HMM.

Both regions contain probabilities that are used parameterize the HMM.
These are stored as integers which are related to the probability via
a log-odds calculation. The log-odds score calculation is defined in
\prog{mathsupport.c} and is:

\[
\mbox{score} = (\mbox{\texttt{int}}) \mbox{\texttt{floor}}(0.5 + (\mbox{\texttt{INTSCALE}} * \log_2(\mbox{prob}/\mbox{null-prob})))
\]

so conversely, to get a probability from the scores in an HMM save
file:

\[
\mbox{prob} = \mbox{null-prob} * 2^{\mbox{score}/\mbox{\texttt{INTSCALE}}}
\]

\prog{INTSCALE} is defined in \prog{config.h} as 1000. 

Notice that you must know a null model probability to convert scores
back to HMM probabilities. 

The special case of prob = 0 is translated to ``*'', so a score of *
is read as a probability of 0. Null model probabilities are not
allowed to be 0.

This log-odds format has been chosen because it has a better dynamic
range than storing probabilities as ASCII text, and because the
numbers are more meaningful to a human reader to a certain extent:
positive values means a better than expected probability, and negative
values a worse than expected probability.  However, because of the
conversion from probabilities, it should be noted that {\em you should
not edit the numbers in a HMMER save file directly}. The HMM is a
probabilistic model and expects state transition and symbol emission
probability distributions to sum to one. If you want to edit the HMM,
you must understand the underlying Plan7 probabilistic model, and
ensure the correct summations yourself.

A more detailed description of the format follows.

\subsection{Header section}

In the header section, each line after the initial identifier has a
unique tag of five characters or less. For shorter tags, the remainder
of the five characters is padded with spaces. Therefore the first six
characters of these lines are reserved for the tag and a space. The
remainder of the line starts at the seventh character. The parser does
require this.

\begin{wideitem}

\item [\emprog{HMMER2.0}]
File format version; a unique identifier for this save file
format. Used for backwards compatibility. {\em Not} necessarily the
version number of the HMMER software that generated it; rather, the
version number of the last HMMER that changed the format so much
that a whole new function had to be introduced to do the parsing.
(i.e., HMMER 2.8 might
still be writing save files that are headed \prog{HMMER2.0}).
\textbf{Mandatory.}

\item [\emprog{NAME  <s>}] Model name; \prog{<s>} is a single word name for the HMM.
No spaces or tabs may occur in the name. 
\prog{hmmbuild} will use the \verb+#=ID+ line from a SELEX alignment
file to set the name. If this is not present, or the alignment
is not in SELEX format, 
\prog{hmmbuild}
sets the HMM name using the name of the alignment file, after removing any
file type suffix. For example, an HMM built from the alignment file
\prog{rrm.slx} would be named \prog{rrm} by default.
\textbf{Mandatory.}

\item [\emprog{ACC   <s>}] Accession number; \prog{<s>} is a one-word
accession number for an HMM. Used in Pfam maintenance. Accessions are
stable identifiers for Pfam models, whereas names may change from
release to release. Added in v2.1.1.  \textbf{Optional.}

\item [\emprog{DESC  <s>}] Description line; \prog{<s>} is a one-line description 
of the HMM. \prog{hmmbuild} will use the \verb+#=DE+ line from a
SELEX alignment file to set the description line. If this is not
present, or the alignment is not in SELEX format, the description
line is left blank; one can be added manually (or by Perl script)
if you wish. \textbf{Optional.}

\item [\emprog{LENG  <d>}] Model length; \prog{<d>}, a positive nonzero integer, 
is the number of match states in the model.
\textbf{Mandatory.}

\item [\emprog{ALPH  <s>}] Symbol alphabet; \prog{<s>} must be either
\prog{Amino} or \prog{Nucleic}. This determines the symbol alphabet and the
size of the symbol emission probability distributions.  If
\prog{Amino}, the alphabet size is set to 20 and the symbol alphabet
to ``ACDEFGHIKLMNPQRSTVWY'' (alphabetic order). If \prog{Nucleic}, the
alphabet size is set to 4 and the symbol alphabet to ``ACGT''.  Case
insensitive. \textbf{Mandatory.}

\item [\emprog{RF    <s>}] Reference annotation flag; \prog{<s>} must
be either \prog{no} or \prog{yes} (case insensitive). If set to
\prog{yes}, a character of reference annotation is read for each match
state/consensus column in the main section of the file (see below);
else this data field will be ignored.  Reference annotation lines are
currently somewhat inconsistently used. The only major use in HMMER is
to specify which columns of an alignment get turned into match states
when using the
\prog{hmmbuild --hand} manual model construction option. Reference
annotation can only be picked up from SELEX format alignments. See
description of SELEX format for more details on reference annotation
lines. \textbf{Optional}; assumed to be no if not present.

\item [\emprog{CS    <s>}] Consensus structure annotation flag;
\prog{<s>} must be either \prog{no} or \prog{yes} (case insensitive). If set to \prog{yes}, a character
of consensus structure annotation is read for each match
state/consensus column in the main section of the file (see below);
else this data field will be ignored. Consensus structure annotation
lines are currently somewhat inconsistently used.  Consensus structure
annotation can only be picked up from SELEX format alignments.  See
description of SELEX format for more details on consensus structure
annotation lines. \textbf{Optional}; assumed to be no if not present.

\item [\emprog{MAP   <s>}] Map annotation flag;
\prog{<s>} must be either \prog{no} or \prog{yes} (case insensitive).
If set to \prog{yes}, each line of data for the match state/consensus
column in the main section of the file is followed by an extra number.
This number gives the index of the alignment column that the match
state was made from. This information provides a ``map'' of the match
states ($1..M$) onto the columns of the alignment ($1..alen$).  It is
used for quickly aligning the model back to the original alignment,
e.g.\ when using \prog{hmmalign --mapali}. Added in v2.0.1.
\textbf{Optional}; assumed to be no if not present.

\item [\emprog{COM   <s>}] Command line log; \prog{<s>} is a one-line
command. There may be more than one \prog{COM} line per save
file. These lines record the command line for every HMMER command that
modifies the save file. This helps us automatically log Pfam
construction strategies, for example. \textbf{Optional.}

\item [\emprog{CKSUM  <d>}] Training alignment checksum; \prog{<d>} is a nonzero
positive integer. This number is calculated from the training
alignment and stored when \prog{hmmbuild} is used. It is used in
conjunction with the alignment map information to to verify that some
alignment is indeed the alignment that the map is for.  Added in
v2.0.1. \textbf{Optional.}

\item [\emprog{GA    <f> <f>}] Pfam gathering thresholds GA1 and GA2.
This is a feature in progress. See Pfam documentation of GA lines.
Added in v2.1.1. \textbf{Optional.}

\item [\emprog{TC    <f> <f>}] Pfam trusted cutoffs TC1 and TC2.
This is a feature in progress. See Pfam documentation of TC lines.
Added in v2.1.1. \textbf{Optional.}

\item [\emprog{NC    <f> <f>}] Pfam noise cutoffs NC1 and NC2.
This is a feature in progress. See Pfam documentation of NC lines.
Added in v2.1.1. \textbf{Optional.}

\item [\emprog{NSEQ  <d>}] Sequence number; \prog{<d>} is a nonzero
positive integer, the number of sequences that the HMM was trained on.
This field is only used for logging purposes.
\textbf{Optional.}

\item [\emprog{DATE  <s>}] Creation date; \prog{<s>} is a date string.
This field is only used for logging purposes.
\textbf{Optional.}

\item [\emprog{XT    <d>*8}] Eight ``special'' transitions for
controlling parts of the algorithm-specific parts of the Plan7 model.
The null probability used to convert these back to model probabilities
is 1.0. The order of the eight fields is N $\rightarrow$ B, N
$\rightarrow$ N, E $\rightarrow$ C, E $\rightarrow$ J, C $\rightarrow$
T, C $\rightarrow$ C, J $\rightarrow$ B, J $\rightarrow$ J.  (Another
way to view the order is as four transition probability distributions
for N,E,C,J; each distribution has two probabilities, the first one
for ``moving'' and the second one for ``looping''.) For an explanation
of these special transitions (and definition of the state names), read
the Plan7 architecture documentation.
\textbf{Mandatory.}

\item [\emprog{NULT  <d> <d>}] The transition probability distribution
for the null model (single G state). The null probability used to
convert these back to model probabilities is 1.0. The order is G
$\rightarrow$ G, G $\rightarrow$ F.
\textbf{Mandatory.}

\item [\emprog{NULE  <d>*K}] The symbol emission probability
distribution for the null model (G state); consists of $K$ (e.g. 4 or
20) integers. The null probability used to convert these back to model
probabilities is $1/K$. (Yes, it's a little weird to have a ``null
probability'' for the null model symbol emission probabilities; this
is strictly an aesthetic decision, so one can look at the null model
and easily tell which amino acids are more common than chance
expectation in the background distribution.) 
\textbf{Mandatory.}

\item [\emprog{EVD   <f> <f>}] The extreme value distribution
parameters $\mu$ and $\lambda$, respectively; both floating point
values. $\lambda$ is positive and nonzero. These values are set when
the model is calibrated with \prog{hmmcalibrate}. They are used to
determine E-values of bit scores. If this line is not present,
E-values are calculated using a conservative analytic upper bound.
\textbf{Optional.}

\item [\emprog{HMM    }] HMM flag line; flags the end of the header
section. Otherwised not parsed. Strictly for human readability, the
symbol alphabet is also shown on this line, aligned to the \prog{NULE}
fields and the fields of the match and insert symbol emission
distributions in the main model. The immediately next line is also an
unparsed human annotation line: column headers for the state
transition probability fields in the main model section that follows.
Both lines are \textbf{mandatory.}

\end{wideitem}

\subsection{Main model section}

All the remaining fields are \textbf{mandatory}, except for the
alignment map.

The first line in the main model section is atypical; it contains
three fields, for transitions from the B state into the first node of
the model. \textit{The only purpose of this line is to set the B
$\rightarrow$ D transition probability}. The first field is the score
for $ 1 - t(B \rightarrow D)$. The second field is always ``*'' (there is no B
$\rightarrow$ I transition). The third field is the score for
$t(B\rightarrow D)$. The null probability used for converting these
scores back to probabilities is 1.0. In principle, only the third
number is needed to obtain $t(B \rightarrow D)$.  In practice, HMMER
reads both the first and the third number, converts them to
probabilities, and renormalizes the distribution to obtain $t(B
\rightarrow D)$. \footnote{OK, it's more complicated than it has to
be. Sometimes you only discover your temporary insanity when you're
trying to document it.}

The remainder of the model has three lines per node, for $M$ nodes
(where $M$ is the number of match states, as given by the \prog{LENG}
line). These three lines are:

\begin{wideitem}

\item [\textbf{Match emission line}] The first field is the node number (1..M).
The HMMER parser verifies this number as a consistency check (it
expects the nodes to come in order). The next $K$ numbers for match
emission scores, one per symbol. The null probability used to convert
them to probabilities is the relevant null model emission probability
calculated from the \prog{NULE} line.

If \prog{MAP} was \prog{yes}, then there is one more number on this
line, representing the alignment column index for this match state.
See \prog{MAP} above for more information about the alignment map, and
also see the man pages for \prog{hmmalign --mapali}.  Added in
v2.0.1. This field is optional, for backwards compatibility with 2.0.

\item [\textbf{Insert emission line}] The first field is a character of
reference annotation (RF), or ``-'' if there is no reference
annotation. The remaining fields are $K$ numbers for insert emission
scores, one per symbol, in alphabetic order. The null probability used
to convert them to probabilities is the relevant null model emission
probability calculated from the \prog{NULE} line.

\item [\textbf{State transition line}] The first field is a character
of consensus structure annotation (CS), or ``-'' if there is no
consensus structure annotation. The remaining 9 fields are state
transition scores. The null probability used to convert them back from
log odds scores to probabilities is 1.0. The order of these scores is
given by the annotation line at the top of the main section: it is M
$\rightarrow$ M, M $\rightarrow$ I, M $\rightarrow$ D; I $\rightarrow$
M, I $\rightarrow$ D; D $\rightarrow$ M, D $\rightarrow$ D; B
$\rightarrow$ M; M $\rightarrow$ E.

\end{wideitem}

The insert emission and state transition lines for the final node $M$
are special.  Node $M$ has no insert state, so all the insert
emissions are given as ``*''. (In fact, this line is skipped by the
parser, except for its RF annotation.) There is also no next node, so
only the B $\rightarrow$ M and M $\rightarrow$ E transitions are
valid; the first seven transitions are always ``*''.  (Incidentally,
the M $\rightarrow$ E transition score for the last node is always 0,
because this probability has to be 1.0.)

Finally, the last line of the format is the ``//'' record separator.

\subsection{Renormalization}

After the parser reads the file and converts the scores back to
probabilities, it renormalizes the probability distributions to sum to
1.0 to eliminate minor rounding/conversion/numerical imprecision
errors.  If you're trying to emulate HMMER save files, it might be
useful to know what HMMER considers to be a probability
distribution. See
\prog{Plan7Renormalize()} in \prog{plan7.c} for the relevant
function.

\begin{wideitem}

\item [\textbf{null emissions}] The $K$ symbol emissions 
given on the \prog{NULE} line.

\item [\textbf{null transitions}] The two null model transitions
given on the \prog{NULT} line.

\item [\textbf{N,E,C,J specials}] Each of the four special states N,E,C,J have two
state transition probabilities (move and loop). All four distributions
are specified on the \prog{XT} line.

\item [\textbf{B transitions}] $M$ B $\rightarrow$
M entry probabilities are given by the 9th field in the state
transition line of each of the $M$ nodes. The B $\rightarrow$ D
transition (from the atypical first line of the main model section) is
also part of this state transition distribution.

\item [\textbf{match transitions}] One distribution of 4 numbers per node; $M \rightarrow M$, 
$M \rightarrow I$, $M \rightarrow D$, and $M \rightarrow E$ (fields 2,
3, 4, and 10 in the state transition line of each node). Note the
asymmetry between B $\rightarrow$ M and M $\rightarrow$ E; entries are
a probability distribution of their own, while exits are not.

\item [\textbf{insert transitions}] One distribution of 2 numbers per node; $I \rightarrow M$, 
$I \rightarrow I$ (fields 5 and 6 of the state transition line of each
node).

\item [\textbf{delete transitions}] One distribution of 2 numbers per
node; $D \rightarrow M$, $D \rightarrow D$ (fields 7 and 8 of the
state transition line of each node).

\item [\textbf{match emissions}] One distribution of $K$ numbers
per node; the $K$ match symbol emissions given on the first line of
each node in the main section.

\item [\textbf{insert emissions}] One distribution of $K$ numbers
per node; the $K$ insert symbol emissions given on the second line of
each node in the main section.

\end{wideitem}

\subsection{Note to developers}

Though I make an effort to keep this documentation up to date, it may
lag behind the code. For definitive answers, please check the parsing
code in \prog{hmmio.c}. The relevant function to see what's being
written is \prog{WriteAscHMM()}. The relevant function to see how it's
being parsed is \prog{read\_asc20hmm()}.


\section{HMMER null model files}

A ``null model'' is used to calculate HMMER log odds scores. The null
model states the expected background occurrence frequencies of the 20
amino acids or the 4 nucleotide bases. The null model also contains a
parameter called p1, which is the $G \rightarrow G$ transition
probability in the Plan7 null model (see the figure in the
Introduction).

For protein models, by default, the 20 residue frequencies are set to
the amino acid composition of SWISS-PROT 34, and p1 is set to 350/351
(which, because the Plan7 null model implies a geometric length
distribution, states that the mean length of a protein is about 350
residues). For DNA/RNA models, by default, the 4 residue frequencies
are set to 0.25 each, and p1 is set to 1000/1001.  [In the code, see
\prog{prior.c:P7DefaultNullModel()}, and the amino acid frequencies are
set in \prog{iupac.c:aafq}.]

Each HMM carries its own null model (see above, HMM file format).  The
null model is determined when the model is built using
\prog{hmmbuild}. The default null model can be overridden using
the \prog{--null <f>} option to \prog{hmmbuild}, where \prog{<f>} is
the name of a null model file.  

Two example null model files,
\prog{amino.null} and \prog{nucleic.null}, are provided
in the \prog{Demos} subdirectory of the HMMER distribution. (They 
are copies of the internal default HMMER null model settings.)
\prog{nucleic.null} looks like this:

{\small\begin{verbatim}
# nucleic.null
#
# Example of a null model file for DNA/RNA sequences.
# The values in this file are the HMMER 2 default
# settings.

Nucleic
0.25     # A
0.25     # C
0.25     # G
0.25     # T
0.999001 # p1
\end{verbatim}}

Anything on a line following a \prog{\#} is a comment, and is ignored
by the software. Blank lines are also ignored. Valid fields are
separated by blanks or new lines. Only the order that the fields occur
in the file is important, not how they're put on lines; for example,
20 required fields can all occur on one line separated by blanks, or
on 20 separate lines. 

There must be 6 or 22 non-comment fields in a null model file,
occurring in the following order:

\begin{wideitem}
\item [\textbf{Alphabet type}] The first (non-comment) word in the
file must be Nucleic or Amino, specifying what kind of sequence the
null model is for.

\item [\textbf{Emission probabilities}] 4 or 20 background
frequencies for the amino acids or nucleotides. These \textit{must}
come in alphabetical order (the A, C, G, T comments in the example
above are only for easier human viewing, and aren't parsed by the
software).

\item [\textbf{p1 probability}] The $G \rightarrow G$ transition
probability in the null model. Basically, if the expected mean length
of target sequences is $x$, p1 should be $\frac{x}{x+1}$.
\end{wideitem}

Null model files are parsed in \prog{prior.c:P7ReadNullModel()}.

\section {HMMER prior files}

Observed counts of emissions (residues) and transitions (insertions
and deletions) in a multiple alignment are combined with
\textit{Dirichlet priors} to convert them to probabilities
in an HMM. 

For protein models, by default, HMMER uses a nine-component mixture
Dirichlet prior for match emissions, and single component Dirichlet
priors for insert emissions and transitions. The nine-component match
emission mixture Dirichlet comes from the work of Kimmen Sj\"{o}lander
\cite{Sjolander96}.

For DNA/RNA models, by default, HMMER uses single component
Dirichlets.

Two example null model files,
\prog{amino.pri} and \prog{nucleic.pri}, are provided
in the \prog{Demos} subdirectory of the HMMER distribution. (They are
copies of the internal default HMMER prior settings.)

The way the format of these files is parsed is identical to null
models: everything after a \prog{\#} on a line is a comment, the order
of occurrence of the fields is important, and fields must be separated
by either blanks or newlines.

A prior file consists of the following fields:

\begin{wideitem}
\item [\textbf{Strategy}] Must be the keyword \prog{Dirichlet}. Currently 
this is the only available prior strategy in the public HMMER release.

\item [\textbf{Alphabet type}] Must be either \prog{Amino} or
\prog{Nucleic}.

\item [\textbf{Transition priors}] 1 + 8a fields, where a
is the number of transition mixture components. The first field is the
number of transition prior components, a (often just 1). Then, for each
component, eight fields follow: the prior probability of that mixture
component (1.0 if there is only one component), then the Dirichlet
alpha parameters for the seven transitions, in order of $M \rightarrow
M$, $M \rightarrow I$, $M \rightarrow D$, $I \rightarrow M$, $I
\rightarrow I$, $D \rightarrow M$, $D \rightarrow I$.

\item [\textbf{Match emission priors}] 1 + (5 or 21)b fields,
where b is the number of match emission mixture components.  The first
field is the number of match emission mixture components, b. Then, for
each component, 5 or 21 fields follows: the prior probability of that
mixture component (1.0 if there is only one component), then the
Dirichlet alpha parameters for the 4 or 20 residue types, in
alphabetical order.

\item [\textbf{Insert emission priors}] 1 + (5 or 21)c fields,
where c is the number of insert emission mixture components.  The
first field is the number of insert emission mixture components,
c. Then, for each component, 5 or 21 fields follows: the prior
probability of that mixture component (1.0 if there is only one
component), then the Dirichlet alpha parameters for the 4 or 20
residue types, in alphabetical order.
\end{wideitem}

In the code, prior files are parsed by \prog{prior.c:P7ReadPrior()}.

\section {Sequence files}

There are a confusing number of sequence file formats use. In any
realm of endeavour where there are a confusion of different options
(life, for instance), it is best to have a Guiding Philosophy.  HMMER
has a Guiding Philosophy 


\subsection{Supported file formats}
 
HMMER can automatically recognize and parse a number of common file
formats. The best supported of these formats are listed below. If you
know your sequence database is in one of these formats, you can use
the file. If you are formatting sequences yourself, see the section of
FASTA format below for unaligned sequences, and the section on SELEX
format for alignments; these are the simplest formats to hand type


\begin{tabular}{ll}
\multicolumn{2}{l}{\textbf{Unaligned sequence formats}} \\
FASTA      & Pearson FASTA format; BLAST databases \\
SWISS-PROT & SWISS-PROT protein sequence database\\ 
PIR        & PIR protein sequence database \\
EMBL       & EMBL DNA sequence database \\
GenBank    & GenBank DNA database flat files\\
GCGdata    & Wisconsin GCG sequence database format \\
GCG        & Wisconsin GCG single sequence format \\
\end{tabular}

\begin{tabular}{ll}
\multicolumn{2}{l}{\textbf{Multiple sequence alignment formats}}\\
SELEX   &   The preferred format for HMMER/Pfam (see below)\\
MSF     &   GCG alignment format \\
CLUSTAL &   CLUSTALW and CLUSTALV format \\
A2M     &   ``Aligned FASTA'' \\ 
\end{tabular}

For programs that do sequential, database-style access (i.e.  where
you'd usually use an unaligned flat file), the alignment formats are
read as if they were multiple unaligned sequences.

There is no provision for enforcing that single unaligned sequence
formats (i.e. GCG unaligned sequence format) are single sequence
only. HMMER will happily try to read more than one sequence if your
file contains more than one. However, this may not give the results
you expected.

Staden ``experiment file'' format is parsed using the EMBL file
parser, but this functionality is relatively unsupported. There is one
wrinkle in this. Staden experiment files use '-' characters to
indicate 'N' -- i.e., that a base is present in a sequence read, but
its identity is unknown. Therefore, the software replaces any '-' in
an EMBL sequence with an 'N'. Sometimes people use the unaligned
formats to distribute aligned sequences by including gap
characters. If EMBL files are used i this way for aligned strings,
they must use a different character than '-' to indicate gaps.

\subsection{FASTA unaligned sequence format}

An example of a simple FASTA file: 

\begin{verbatim}
> seq1 This is the description of my first sequence.
AGTACGTAGTAGCTGCTGCTACGTGCGCTAGCTAGTACGTCA
CGACGTAGATGCTAGCTGACTCGATGC
> seq2 This is a description of my second sequence.
CGATCGATCGTACGTCGACTGATCGTAGCTACGTCGTACGTAG
CATCGTCAGTTACTGCATGCTCG
\end{verbatim}

FASTA is probably the simplest of formats for unaligned sequences.
FASTA files are easily created in a text editor.  Each sequence is
preceded by a line starting with \verb+>+. The first word on this line
is the name of the sequence. The rest of the line is a description of
the sequence (free format). The remaining lines contain the sequence
itself. You can put as many letters on a sequence line as you want.

Blank lines in a FASTA file are ignored, and so are spaces or other
gap symbols (dashes, underscores, periods) in a sequence. Any other
non-amino or non-nucleic acid symbols in the sequence should produce
an appropriately strident string of warnings on yur terminal screen
when you try to use the file.

HMMER currently has a limit of 4095 characters on lines in files.  You
may see this limitation in NCBI NR databases, where some description
lines will be truncated by HMMER. 

\subsection{SELEX alignment format}

An example of a simple SELEX alignment file:

\begin{verbatim}
# Example selex file

seq1     ACGACGACGACG.
seq2     ..GGGAAAGG.GA
seq3     UUU..AAAUUU.A

seq1  ..ACG
seq2  AAGGG
seq3  AA...UUU
\end{verbatim}

SELEX is an interleaved multiple alignment format that arose as an
intuitive format that was easy to write and manipulate manually with a
text editor like emacs. It is usually easy to convert other alignment
formats into SELEX format, even with a couple of lines of Perl, but it
can be harder to go the other way, since SELEX is more free-format
than other alignment formats. For instance, GCG's MSF format and the
output of the CLUSTALV multiple alignment program are similar
interleaved formats that can be converted to SELEX just by stripping a
small number of non-sequence lines out. Because SELEX evolved to
accomodate different user input styles, it is very tolerant of various
inconsistencies such as different gap symbols, varying line lengths,
etc.

Each line contains a name, followed by the aligned sequence. A space,
dash, underscore, or period denotes a gap. If the alignment is too
long to fit on one line, the alignment is split into multiple blocks,
separated by blank lines. The number of sequences, their order, and
their names must be the same in every block (even if a sequence has no
residues in a given block!) Other blank lines are ignored. You can add
comments to the file on lines starting with a \verb+#+.

SELEX stands for ``Systematic Evolution of Ligands by Exponential
Enrichment'' -- it refers to the Tuerk and Gold technology for
evolving families of small RNAs for particular functions
\cite{Tuerk90b}. SELEX files were what we used to keep track of
alignments of these small RNA families. It's an interesting piece of
historical baggage -- most of my lab works on RNA, not protein.

As the format evolved, more features have been added. To maintain
compatibility with past alignment files, the new features are added
using a reserved comment style. You don't have to worry about adding
these extra information lines. They are generally the province of
automated SELEX-generating software, such as my \prog{koala} sequence
alignment editor or the \prog{COVE} and HMMER sequence analysis
packages. This extra information includes consensus and individual RNA
or protein secondary structure, sequence weights, a reference
coordinate system for the columns, and database source information
including name, accession number, and coordinates (for subsequences
extracted from a longer source sequence) See below for details.

\subsubsection {Detailed specification of a SELEX file}

\begin{enumerate}
\item
Any line beginning with a \verb+#=+ as the first two characters is a
machine comment.  \verb+#=+ comments are reserved for parsed data
about the alignment. Often these features are maintained by software
such as the {\tt koala} editor or the HMMER software, not by hand. The
format of \verb+#=+ lines is usually quite specific, since they must
be parsed by the file-reading software.

\item
All other lines beginning with a \verb+%+ or \verb+#+ as the first
character are user comments.  User comments are ignored by all
software. Anything may appear on these lines. Any number of comments
may be included in a SELEX file, and at any point.

\item
Lines of data consist of a name followed by a sequence. The total
length of the line must be smaller than 4096 characters.

\item
Names must be a single word. Any non-whitespace characters are
accepted.  No spaces are tolerated in names: names MUST be a
single word. Names must be less than 32 characters long.

\item In the sequence, any of the characters \verb+-_.+ or a space are
recognized as gaps. Any other characters are interpreted as sequence.
Sequence is case-sensitive. There is a common assumption by my
software that upper-case symbols are used for consensus (match)
positions and lower-case symbols are used for inserts. This language
of ``match'' versus ``insert'' comes from the hidden Markov model
formalism \cite{Krogh94}. To almost all of my software, this isn't
important, and it immediately converts the sequence to all upper-case
after it's read.

\item
Multiple different sequences are grouped in a block of data lines.
Blocks are separated by blank lines. No blank lines are tolerated
between the sequence lines in a block. Each block in a multi-block
file of a long alignment must have its sequences in the same order in
each block. The names are checked to verify that this is the case; if
not, only a warning is generated. (In manually constructed files, some
users may wish to use shorthand names in subsequent blocks after an
initial block with full names -- but this isn't recommended.)
\end{enumerate}

\subsubsection {Optional SELEX file annotation}

\subsubsection {Header}

Several pieces of information can be added to the header of the file
using the following machine comments:

\begin{wideitem}

\item [\emprog{\#=ID  <s>}]
Name of the alignment; \prog{<s>} is one word, no spaces (example: ``rrm'').
If present, HMMER's \prog{hmmbuild} picks this up and uses it as the
name of an HMM.

\item [\emprog{\#=AC  <s>}]
Accession number of the alignment; \prog{<s>} is one word, no spaces
(example: ``PF99999''). If present, HMMER's \prog{hmmbuild} picks this
up and uses it as the accession number of an HMM. (This is fairly
specific to the support of the Pfam HMM database.)

\item [\emprog{\#=DE  <s>}]
Description line; \prog{<s>} is a one-line description of the
alignment. If present, HMMER's \prog{hmmbuild} picks this up and
uses it as the description line of an HMM.

\item [\emprog{\#=AU  <s>}]
Author line;  \prog{<s>} is a one-line description of who made the
alignment. HMMER doesn't use this line for anything.

\item [\emprog{\#=GA  <f1> <f2>}]
Gathering cutoffs; \prog{<f1>} is the per-sequence GA1 cutoff,
\prog{<f2>} is the per-domain GA2 cutoff. 
Both numbers are floating point numbers (HMMER bit scores).
This is very specific to Pfam support. The GA cutoffs specify
the HMMER score cutoffs used in automatically generating the
Pfam full alignments.

\item [\emprog{\#=TC  <f1> <f2>}]
Trusted cutoffs; \prog{<f1>} is the per-sequence TC1 cutoff,
\prog{<f2>} is the per-domain TC2 cutoff. 
Both numbers are floating point numbers (HMMER bit scores).
This is very specific to Pfam support. The TC cutoffs specify
the HMMER scores of the lowest-scoring sequence/domain included
in a Pfam full alignment.

\item [\emprog{\#=NC  <f1> <f2>}]
Noise cutoffs; \prog{<f1>} is the per-sequence NC1 cutoff,
\prog{<f2>} is the per-domain NC2 cutoff. 
Both numbers are floating point numbers (HMMER bit scores).
This is very specific to Pfam support. The NC cutoffs specify
the HMMER scores of the highest scoring sequence/domain that 
were not included in a Pfam full alignment.

\end{wideitem}

\subsubsection {Sequence header}

Additional per-sequence information can be placed after the main
header lines and before any blocks appear. These lines, one per
sequence and in exactly the same order as the sequences appear in the
alignment, are formatted like

{\small \begin{verbatim}
#=SQ <name> <wgt> <source> <accession> <start..stop::orig length> <desc>
\end{verbatim}}

This information includes a sequence weight (for compensating for
biased representation of subfamilies of sequences in the alignment);
source information, if the sequence came from a database, consisting
of identifier, accession number, and source coordinates; and a
description of the sequence.

If a \verb+#=SQ+ line is present, all the fields must be present on
each line and one \verb+#=SQ+ line must be present for each sequence.
If no information is available for a field, use '-' for all the fields
except the source coordinates, which would be given as '0'.

\subsubsection {Secondary structure annotation}

Lines beginning with \verb+#=SS+ or \verb+#=CS+ are individual or
consensus secondary structure data, respectively.  \verb+#=SS+
individual secondary structure lines must immediately follow the
sequence they are associated with.  There can only be one \verb+#=SS+
per sequence. All, some, or none of the sequences may have \verb+#=SS+
annotation.

\verb+#=CS+ consensus secondary structure predictions precede all the
sequences in each block. There can only be one \verb+#=CS+ per file.

I use one-letter codes to indicate secondary structures. Secondary
structure strings are aligned to sequence blocks just like additional
sequences.

For RNA secondary structure, the symbols \verb+>+ and \verb+<+ are
used for base pairs (pairs point at each other).  \verb-+- indicate
definitely single-stranded positions, and any gap symbol indicates
unassigned bases or single-stranded positions.  This description
roughly follows \cite{Konings89}.  For protein secondary structure, I
use {\tt E} to indicate residues in $\beta$-sheet, {\tt H} for those
in $\alpha$-helix, {\tt L} for those in loops, and any gap symbol for
unassigned or unstructured residues.

RNA pseudoknots are represented by alphabetic characters, with upper
case letters representing the 5' side of the helix and lower case
letters representing the 3' side. Note that this restricts the
annotation to a maximum of 26 pseudoknots per sequence.

\subsubsection {Reference coordinate system}

Alignments are usually numbered by some reference coordinate system,
often a canonical molecule. For instance, tRNA positions are numbered
by reference to the positions of yeast tRNA-Phe.

A line beginning with \verb+#=RF+ preceding the sequences in a block
gives a reference coordinate system. Any non-gap symbol in the
\verb+#=RF+ line indicates that sequence positions in its columns are
numbered. For instance, the \verb+#=RF+ lines for a tRNA alignment
would have 76 non-gap symbols for the canonical numbered columns; they
might be the aligned tRNA-Phe sequence itself, or they might be just
X's.

The \verb+#=RF+ line also provides a good way to mark conserved key
residues in a protein alignment. HMMER picks up both the \verb+#=RF+
and \verb+#=CS+ lines when it builds an HMM, if they're there, and
will display them in the context of any alignments to target
sequences.

\subsection{An example SELEX file with annotation}

Here's an example SELEX file with examples of all the optional fields.
The sequences are evolved RNA ligands for the phage R17 coat protein
\cite{Schneider92}.

\begin{verbatim}
#=ID r17
#=AC RNA00001
#=DE RNA ligands evolved to bind phage R17 coat protein 
#=GA 0.0 0.0
#=TC 0.0 0.0
#=NC 0.0 0.0
#=AU COVE 2.2.3 Wed Dec  2 08:39:58 1998

#=SQ lig28 1.0 - - 1..29:29 R17 coat protein ligand 28
#=SQ lig1  1.0 - - 1..17:17 R17 coat protein ligand 1
#=SQ lig2  1.0 - - 1..29:29 R17 coat protein ligand 2

#=RF         ***A** loop *****
#=CS  .......>>>+>> ++++ <<<<<....... 
lig28 GGAGUAAGAUAGC AUCA GCAUCUUGUUCC
#=SS   >>>>>>>>>+>> ++++ <<<<<<<<<<<<
lig1        GUUCACC AUCA GGGGAC
#=SS        >>>>+>> ++++ <<<<<<
lig2  AUGGAUGCGCACC AUCA GGGCGUAUCUAU
#=SS  >>>>>>>>>>+>> ++++ <<<<<<<<<<<<
\end{verbatim}


\section{Count vector files}

\prog{hmmbuild} saves a ``count vector file'' when the \prog{--cfile}
option is invoked. The count vector file contains observed weighted
counts for match emissions, insert emissions, and state transitions.
The intended use of the count vector file is for training mixture
Dirichlet priors (something we do locally), but since it may be useful
for other purposes, the format is documented here.

Each line of the file is an annotated count vector. The format of this
line is:

\begin{wideitem}
\item[\textbf{Vector type}] The first field is a single letter M,
I, or T, specifying whether the line is for a match emission, insert
emission, or transition vector.

\item[\textbf{Counts}] The next several fields are the counts
themselves. 

For match and insert emission vectors, there are either 4 or 20 real
numbers, depending on whether the alignment was DNA/RNA or protein,
respectively; and the counts are in alphabetical order by residue
(``ACGT'' for DNA/RNA, ``AC..WY'' for protein).

For state transition vectors, there are 7 real numbers, in order MM,
MI, MD, IM, II, DM, DD.

The counts are real numbers, not integers, because they're
weighted. Both relative weights (default: tree weights) and absolute
weights (effective sequence number) affect the observed counts. (They
are exactly the numbers used by HMMER before addition of Dirichlet
prior pseudocounts and renormalization.) Options affecting either
relative or absolute weighting will therefore affect the count
vectors. To see unweighted raw count vectors, add \prog{--wnone
--idlevel 1.0} to the \prog{hmmbuild} command line.

\item[\textbf{Alignment name}] If the alignment was in Stockholm
format (for example, a Pfam distribution), the name of the alignment
is recorded in this field. (A count vector file may contain vectors
from a large number of alignments.) If this information is
unavailable, ``-'' appears instead.

\item[\textbf{Alignment column}] An integer indicating which alignment
column this count vector corresponds to. In combination with the
alignment name, this allows you to retrieve other annotation from the
vicinity of this count vector in the original alignment file if you
need to.

\item[\textbf{HMM node}] An integer indicating which HMM node this
vector corresponds to. This number is always $\leq$ the alignment
column index, because some alignment columns are skipped in
constructing an HMM. 

Note that count vectors are only recorded for the alignment columns
that became HMM match states. If you want to collect a count vector
from \emph{every} alignment column, you need to make \prog{hmmbuild}
assign every column to a match state. You can do this by invoking the
\prog{--fast --gapmax 1.0} options to \prog{hmmbuild}.

\item[\textbf{Structure annotation}] The next 2
fields are single characters representing structural annotation
for this column in the alignment, if available. If not,
``-'' characters appear.

The first field is Stockholm format's \verb+#=GC SS_cons+ secondary
structure consensus annotation for the column. This is a single letter
DSSP code.

The second field is Stockholm format's \verb+#=GC SA_cons+ surface
accessibility annotation for the column. This is a single character
0-9 (representing $<$10\% to $<$100\% accessibility), or X for
unknown, or - or . for columns that are gaps in all the known
structures in the alignment.

\item[\textbf{More structure annotation}] Transition vectors
(only) have another two fields of structure annotation for the 
\emph{next} (k+1'th) HMM node. Transition vectors are thought of as
being between the k'th and the k+1'th HMM node, so most applications
would probably want to see the annotation for both.  Note that this
does not necessarily correspond to the annotation on the next
alignment column, because that column is not necessarily assigned to
an HMM node.

\end{wideitem}



